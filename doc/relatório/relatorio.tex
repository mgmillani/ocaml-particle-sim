\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{color}
\usepackage{float}
\usepackage{listings}

\hypersetup
{
	colorlinks=true,
	linkcolor=blue
}

\definecolor{darkGreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.2,0.2,0.2}

\lstset{
	extendedchars=true,
	inputencoding=utf8,
	basicstyle=\small,
	keywordstyle=\color{red}\bfseries,
	identifierstyle=\color{darkGreen},
	commentstyle=\color{gray}\textit,
	stringstyle=\color{magenta},
	showstringspaces=false,
	tabsize=2,
	language=[Objective]Caml,
	numbers=left,         % Números na margem da esquerda
	numberstyle=\tiny,    % Números pequenos
	stepnumber=1,         % De 1 em 1
	frame=single,
	numbersep=5pt         % Separados por 5pt
}

\lstset
{
	literate={ê}{{\^e}}1 {ç}{{\c{c}}}1 {ã}{{\~a}}1 {â}{{\^a}}1 {õ}{{\~o}}1 {í}{{\'i}}1 {é}{{\'e}}1 {á}{{\'a}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
}

\title{Objetivos Atingidos}
\author{Aline \and Marcelo Garlet Millani}

\definecolor{notDone}{RGB}{240,30,5}
\definecolor{done}{RGB}{15,125,15}

\begin{document}

\maketitle

\begin{abstract}
 Este trabalho implementa um simulador de partículas elétricas e de corpos massivos em OCaml.
\end{abstract}

\section{Descrição do problema}

	O problema consiste em, dado um conjunto de partículas, similar as forças de atração elétrica entre elas, desenhando-as conforme se movem.
	
	Para desenhar numa janela, usamos as bibliotecas lablgl e lablglut, que são, respectivamente, implementações de OpenGl e GLUT para OCaml.
	
\section{OCaml}

	OCaml é uma linguagem multi-paradigma que apresenta características imperativas, funcionais e de orientação a objetos. Atualmente, é a principal implementação de Caml.
	
	Possui características de ML, como tipagem estática, que permite uma maior confiabilidade no código por sabermos em tempo de compilação que não haverão operações não definidas, e inferência de tipos, permitindo que o programador não se preocupe com o tipo de cada variável e melhorando a redigibilidade e diminuindo o acoplamento por tipagem.
	
	Outra propriedade muito interessante de OCaml é pattern matching, pois aumenta consideravelmente a expressividade da linguagem ao descrever construções if-else encadeadas através de uma sintaxe muito mais clara, além de permitir uma decomposição estrutural de forma mais natural.
	
	Por ser uma linguagem compilada, com tipagem estática e uso de referências a memória, programas em OCaml são bastante eficientes, fazendo com que a linguagem possa ser usada em diversos casos práticos, diferentemente de algumas linguagens como Python e Java, que apresentam um custo em processamento ou memória proibitivos para diversas aplicações.
	
	A orientação a objetos de OCaml permite o encapsulamento de informações ao fornecer para o programador meios de definir métodos e atributos privados ou públicos. Python não possui mecanismos para isso, de forma que convenções devem ser adotados. Por um lado, se tudo for público há maior flexibilidade, mas o uso de uma classe pode se tornar mais obscuros por não sabermos quais alterações manterão a consistência dos dados.
	
\section{Implementação}

\subsection{Definição e uso de classes}
	Foram criadas 3 classes: Body, Particle e Electric, sendo Body abstrata.
	\begin{figure}[H]
	\centering	
\begin{lstlisting}
class virtual body:
	float ->
	float ->
	object
		val mutable position : float * float
		val mutable velocity : float * float
		val mutable acceleration : float * float
		method getPosition : float*float
		method setPosition : float*float -> unit
		method getAcceleration : float*float
		method loopBound : float*float -> float*float -> unit
		method setAcceleration : float*float-> unit
		method applyAcceleration : float*float -> unit
		method virtual draw : unit
		method move : unit
	end;;
	\end{lstlisting}
	\caption{Interface da classe body}
\end{figure}
	
\subsection{Encapsulamento e proteção dos atributos}
	Todos os atributos das classes são privados. O encapsulamento de dados pode ser visto através do método move, por exemplo, que esconde o fato de se estar usando três vetores (posição, velocidade e aceleração) para se calcular o movimento da partícula.
\begin{figure}[H]
	\centering	
	\begin{lstlisting}
method move =
	let (px,py) = position in
	let (vx,vy) = velocity in
	let (ax,ay) = acceleration in
	position <- (px +. vx,py +. vy);
	velocity <- (vx +. ax,vy +. ay);
	acceleration <- (0.0,0.0)
	\end{lstlisting}
	\caption{Implementação do método move da classe body}
\end{figure}
	
\subsection{Organização do código em espaços de nome diferenciados}
	Em OCaml, cada arquivo conta como um espaço diferente, de forma que este deve ser incluído com open ou prefixado com seu nome antes de ser possível usar suas funções.
	
\subsection{Mecanismo de Herança}
	Foram usados três níveis de hierarquia, sendo que body é a superclasse de particle, que por sua vez é superclasse de electric.

	\begin{figure}[H]
	\centering	
	\begin{lstlisting}
class particle x y =
	object (self)
		inherit body x y
		method draw =
			GlDraw.begins `points;
			GlDraw.vertex2 position;
			GlDraw.ends ()
	end;;
	\end{lstlisting}
	\caption{Implementação da classe particle, mostrando a herança}
\end{figure}

\subsection{Especificação de uma classe abstrata}
	A classe body é abstrata por possuir o método draw como virtual.

\subsection{Polimorfismo por inclusão}
	
	Usamos polimorfismo por inclusão para desenhar os corpos. Partículas elétricas possuem uma função de desenho diferente de partículas massivas
	
\subsection{Polimorfismo paramétrico}
	
		Foi usada uma quadtree para a simulação das interações entre as partículas. A definição da estrutura é válida para qualquer tipo de dado, mas apenas um de cada vez, isto é, podemos ter uma árvore de inteiros, de partículas, etc... mas não podemos misturar floats e ints na mesma árvore.
		
		Como OCaml usa inferência de tipos, o tipo da árvore não precisa estar explícito no código.
		
	\begin{figure}[H]
	\centering	
	\begin{lstlisting}
type 'a quadtree =
| Empty
| Leaf of 'a
| Node of 'a quadtree*'a quadtree*'a quadtree*'a quadtree;;
	\end{lstlisting}
	\caption{Descrição da estrutura de uma quadtree. ????? indica o tipo parametrizado }
	\end{figure}
	
\subsection{Polimorfismo por sobrecarga}
	
	OCaml não suporta polimorfismo por sobrecarga. Isso está relacionado com o mecanismo de inferência de tipos, que seria muito mais complicado de se implementar (talvez até impossível para qualquer caso). No entanto, a linguagem permite a criação de funções que recebem parâmetros de tipos arbitrários (como, por exemplo, map), mas a implementação é a mesma para todos os tipos.

\subsection{Especificação e uso de funções como elementos de primeira ordem}
	
	Para carregar as partículas de um arquivo, foi feita uma função para ler as linhas de um canal, que foi passada como argumento para a função parseChannel.
	
	\begin{figure}[H]
	\centering	
	\begin{lstlisting}
let readLine chan =
	let rec readLineAux acc =
		let c =
			try
				input_char chan
			with
				End_of_file ->
				if String.length acc = 0 then
					raise End_of_file
				else '\n'
		in
		match c with
		 '\n' -> acc
		|'\r' -> acc
		|' ' ->
			if String.length acc = 0 then readLineAux acc else acc
		|'\t' ->
			if String.length acc = 0 then readLineAux acc else acc
		| _ -> (readLineAux (acc ^ (String.make 1 c)) )
	in
		readLineAux ""
		
let loadConfig filename categoryFunc =
	let chan = open_in_bin filename in
	let lines = parseChannel chan readLine in
	parseList categoryFunc lines
	\end{lstlisting}
	\caption{Função que lê uma linha de um arquivo e outra que carrega o arquivo de configuração}
\end{figure}
	
\subsection{Especificação e uso de funções de ordem maior}

Foi feita uma função que lê o conteúdo de um arquivo, sendo que um de seus parâmetros é uma função que recebe um canal e retorna um elemento.

\begin{figure}[H]
	\centering	
	\begin{lstlisting}
let rec parseChannel chan readElement =
	try
		let el = readElement chan in
		el::(parseChannel chan readElement)
	with
		End_of_file -> []
	\end{lstlisting}
	\caption{Função que lê o conteúdo de um arquivo}
\end{figure}
	
\subsubsection{Currying}
	
	Foi usado currying para a função de callback de display da glut. Como essa deve ser do tipo unit, mas queríamos uma que recebesse uma lista de pontos, simplesmente aplicamos display a dots, produzindo, assim, uma função do tipo unit, mesmo que display recebesse um argumento.
	
	\begin{figure}[H]
	\centering	
	\begin{lstlisting}
let display dots ()=
	GlClear.clear [ `color ];
	drawDots !dots;
	Glut.swapBuffers ()
	
let _ = 
	ignore (Glut.init Sys.argv);
	Glut.initDisplayMode ~double_buffer:true ();
	ignore (Glut.createWindow ~title:"Simparticle");

	Glut.displayFunc ~cb:(display dots);
	Glut.reshapeFunc ~cb:reshape;
	Glut.mouseFunc ~cb:mouseHandler;
	Glut.timerFunc ~ms:mili ~cb:timerF ~value:1;
	Glut.mainLoop()
	\end{lstlisting}
	\caption{Funções display e main do programa}
\end{figure}
	
\subsection{Pattern Matching}

Diversas funções feitas usaram pattern matching. A versão sem pattern matching das mesmas seria mais longa e menos legível. No exemplo abaixo, seria necessário fazer ifs possivelmente longos ou criar uma máquina de estados para se obter o mesmo comportamento.

\begin{figure}[H]
	\centering	
	\begin{lstlisting}
let readElectricParticle lst =
	let rec readAux x y charge lst = match lst with
		 "x"::"="::value::rest -> 
			readAux (fun k -> float_of_string value) y charge rest
		|"y"::"="::value::rest -> 
			readAux x (fun k -> float_of_string value) charge rest
		|"charge"::"="::value::rest ->
			readAux x y (fun k -> float_of_string value) rest
		| h::r -> (new electric (x 0) (y 0) (charge 0) , r)
		| _ -> (new electric (x 0) (y 0) (charge 0) , lst)
	in
		let none = (fun x -> raise Invalid_format) in
		readAux none none none lst
	\end{lstlisting}
	\caption{Função que usa pattern matching}
\end{figure}

	Para uma análise mais detalhada desda função, ver Figura \ref{readElectricParticle}.

\subsection{Recursão como mecanismo de iteração}

\begin{figure}[H]
	\centering	
	\begin{lstlisting}
let rec drawDots points = match points with
  | h::r -> h#draw;
						drawDots r;
	| [] -> ()
	\end{lstlisting}
	\caption{Função para desenhar uma lista de pontos na tela}
\end{figure}
	
\subsection{Delegates}
	
	Como OCaml suporta funções como elementos de primeira ordem, delegates se tornam completamente desnecessários, uma vez que são apenas uma forma de se passar métodos como argumento para alguma classe em paradigmas orientados a objeto. Como é possível passar a função diretamente, OCaml não possui sintaxe para delegates.
	
\begin{itemize}  
 \item Uso de lista para manipulação de estruturas em funções de ordem maior (as funções devem ser puras) 

\end{itemize}

\section{Análise da Linguagem}

\begin{table}[H]
 \begin{tabular}{c | c}
  \hline
  característica & nota \\
  \hline
  simplicidade & 8/10\\
  ortogonalidade & 5/10\\
  expressividade & 8/10\\  
  estruturas de controle & 10/10\\
  mecanismos de definição de tipos & 10/10\\
  abstração de dados e processos & 10/10\\
  modelo de tipos & 8/10\\
  portabilidade & 7/10\\
  reusabilidade & 8/10\\
  suporte e documentação & 4/10\\
  tamanho do código & 9/10\\
  generalidade & 9/10\\
  eficiência e custo & 10/10\\
  \hline
 \end{tabular}
	\caption{Notas das características da linguagem segundo a opinião do grupo}
\end{table}

	\subsection{Simplicidade}
		Graças ao sistema de inferência de tipos e ao pattern matching, a declaração de funções e o uso de tipos de dados se torna bastante simples para o programador.
		
		No entanto, a necessidade de se usar operadores aritméticos diferentes para tipos diferentes, o uso de let rec para funções recursivas e a ausência de coerção implícita torna a linguagem mais complicada de se usar em alguns casos como, por exemplo, ao misturarmos números inteiros e flutuantes na mesma expressão.
		
		Na seguinte função, podemos notar diversos aspectos da linguage:
		\begin{figure}
\begin{lstlisting}
let readElectricParticle lst =
	let rec readAux x y charge lst = match lst with
		 "x"::"="::value::rest -> 
			readAux (fun k -> float_of_string value) y charge rest
		|"y"::"="::value::rest -> 
			readAux x (fun k -> float_of_string value) charge rest
		|"charge"::"="::value::rest ->
			readAux x y (fun k -> float_of_string value) rest
		| h::r -> (new electric (x 0) (y 0) (charge 0) , r)
		| _ -> (new electric (x 0) (y 0) (charge 0) , lst)
	in
		let none = (fun x -> raise Invalid_format) in
		readAux none none none lst
	\end{lstlisting}
		\caption{Função que lê os dados de uma partícula elétrica}
		\label{readElectricParticle}
		\end{figure}
		
		Sem pattern matching, seria necessário fazer diversos if-elses, várias comparações de strings e percorrer a lista manualmente. A outra opção seria fazer um autômato, que também requereria mais código.
		
		O uso de funções lambda permitiu que uma exceção fosse gerada somente nos casos em que um dos atributos não fosse inicializado e sem ser necessário usar variáveis auxiliares nem testar o valor dos atributos até então.
		
		Podemos ver um caso de recursão como método de iteração, pois estamos percorrendo a lista de palavras do início até acharmos um ``end''. Graças ao pattern matching, a versão recursiva é mais simples que a iterativa por poder consumir diversos elementos de uma só vez sem explicitamente alterar o índice.
		
		Se a linguagem usasse coerção implícita de string para float, o código ficaria mais simples pois os casts explícitos desapareceriam.
		
	\subsection{Ortogonalidade}
		O pattern matching permite tratar diversos tipos de dados de uma forma similar e bastante expressiva, o que aumenta a ortogonalidade da linguagem. Por outro lado, a necessidade de usarmos operadores diferentes para soma de inteiros e de floats baixa consideravelmente essa característica.
		
	\subsection{Expressividade}
		Novamente por causa de pattern matching e inferência de tipos, a expressividade da linguagem é bastante boa.
		
	\subsection{Estruturas de Controle}
		OCaml conta com os mecanismos de controle de linguagens imperativas, map de linguagens funcionais, um if-then-else que retorna um valor e pattern matching. Praticamente qualquer método de controle de fluxo que conhecemos pode ser usado em OCaml.
		
	\subsection{Mecanismos de Definição de Tipos}
		A linguagem permite a declaração de classes no estilo orientado a objetos, além de um meio de definir estruturas que possuem diversos construtores e registros com campos nomeados. 
		
	\subsection{Abstração de Dados e Processos}
		A expressão let da linguagem permite nomear qualquer expressão válida. Junto com funções lambda e currying, isso permite uma alta abstração de processos, pois podemos encapsular uma função dentro de uma expressão lambda para gerar uma nova função com comportamento específico, por exemplo.
		
	\subsection{Modelo de Tipos}
		
		
		
	\subsection{Portabilidade}
		
		Embora a linguagem em si seja portável, é necessário usar o cygwin para compilar algum programa OCaml em plataformas Windows. No entanto, isso é mais uma restrição pela existência de ferramentas e não pela linguagem em si, isto é, um código OCaml feito para Linux deve funcionar perfeitamente bem em qualquer outra plataforma desde que existe um compilador para esta.
		
	\subsection{Reusabilidade}
	
		A linguagem permite dividir o código em módulos e estes podem ser usados facilmente a partir de outros arquivos. Como as funções são naturalmente polimórficas (usando tipos genéricos), o potencial de reúso é bastante grande. Também possui orientação a objetos, sendo possível estender classes caso a biblioteca não forneça algo completo o suficiente para a aplicação.
		
		No entanto, a solução para dependências circulares não é simples, o que dificulta a criação de bibliotecas maiores e, consequentemente, o reúso das mesmas.
	
	\subsection{Suporte e Documentação}
	
		Existe pouca documentação sobre a linguagem e suas bibliotecas. Em particular, foi necessário olhar as headers da biblioteca lablgl para se saber como usá-la e quais funções existiam pois não havia algum lugar listando-as e explicando-as.
		
		Nós encontramos a referência para as funções da biblioteca padrão de OCaml, mas para questões de sintaxe como o uso de classes e a declaração de tipos para funções e para aspectos como compilação a informação era mais escassa, sendo necessário fazer tentativa e erro em alguns casos.
		
	\subsection{Tamanho do Código}
		
		Graças a inferência de tipos, não é necessário anotar quais são os tipos das variáveis, reduzindo o tamanho do código. Como a linguagem é fortemente tipada, não é necessário fazer verificação de tipos em execução.
		
		O pattern matching consegue reduzir consideravelmente a quantidade necessária de código para se fazer algo.
		
		Finalmente, características funcionais como funções lambda, currying e a facilidade de se definir funções locais fazem com que o código não precise de linhas ``inúteis'' com atribuições, declarações e variáveis temporárias.
		
	\subsection{Generalidade}
	
		Por causa de sua eficiência, OCaml pode ser usada para muitas aplicações, mesmo as mais pesadas ou críticas. E como é bastante expressiva, pode também ser usada para escrever aplicações pequenas rapidamente, ainda mais por possuir um interpretador além do compilador, de forma que não é necessário gerar o binário e os objetos intermediários para se executar o programa.
		
		Como a linguagem não permite um controle tão preciso de ponteiros como C, não seria muito adequada para um sistema operacional. Por outro lado, é possível usar bibliotecas escritas e C junto com OCaml, viabilizando a criação de projetos híbridos.
	
	\subsection{Eficiência e Custo}
	
		OCaml é uma linguagem compilada com tipagem forte e estática. Além disso, permite o uso de referências a memória. O compilador é bom o suficiente para produzir código com eficiência próxima de linguagens como C++.
	
\section{Conclusões}

	A primeira dificuldade que encontramos foi aprender a linguagem, pois nunca havíamos usado OCaml antes e a documentação dela não é muito abundante. Felizmente a linguagem é bastante parecida com ML e Haskell, fazendo com que o estilo da sintaxe em si não parecesse estranho, mas detalhes foram um pouco complicados de se encontrar.
	
	O fato de a linguagem ser funcional facilitou bastante o uso da Quadtree por ser um estrutura naturalmente recursiva. Junto com pattern matching, cálculo lambda e a existência de múltiplos construtores para a mesma estrutura, essa função se tornou bem mais simples do que o equivalente em outras linguagens.
	
	A leitura do arquivo para carregar os corpos também foi bastante simples graças a pattern matching e aos tipos estruturados, pois foi possível separar em casos algo que seria transformado em um autômato para fazer o parsing.
	
\begin{thebibliography}{4}
 \bibitem{BarnesHut}\url{http://en.wikipedia.org/wiki/Barnes-Hut\_simulation}
 \bibitem{OCamlLibRef}\url{http://caml.inria.fr/pub/docs/manual-ocaml/libref/}
 
\end{thebibliography}


\end{document}
